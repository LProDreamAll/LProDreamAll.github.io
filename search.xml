<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[3-原子性问题的由来、资源如何保护]]></title>
    <url>%2F2019%2F03%2F23%2Fjavacurrent3%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-evKrCOHz"), narrow: false, autoplay: true, showlrc: false, music: { title: "我要你", author: "任素汐", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/%E4%BB%BB%E7%B4%A0%E6%B1%90%20-%20%E6%88%91%E8%A6%81%E4%BD%A0.mp3", pic: "http://p2.music.126.net/dDV995SIeG5-IN1eYq6FOg==/3300733912593978.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 这两年过得好惭愧，不想成为一个业余的小残废原子性问题的由来、资源如何保护？原子性：一个或者多个操作在cpu执行的过程中不被中断的特性。原子性问题的源头就是线程切换（操作系统直接操作），这个又是依赖CPU中断的，简单理解禁止CPU发生中断就解决了原子性问题？1在单核cpu可以，多核并不行！ 例如：在32位CPU上的long类型的写操作12在32位系统中，禁止了cpu中断，那么两次写操作一定是要么同时执行，要么都没有被执行，具有原子性！多核CPU中long类型的写操作时，两个线程分别在CPU1，CPU2上。 此时禁止CPU中断只能保证CPU上线程执行，并不能保证同一时刻只有一个线程执行！也就是说并没有达到同一时刻只有一个线程执行的这个条件1锁模型的出现（不局限于java），我刚开始认为是这样的： 简易锁模型1典型的执行代码片段进行加锁和释放锁操作！ 完善锁模型但是详细的来讲，锁是什么？资源是什么？（保护的资源、锁）12锁：LR,受保护资源：R，加锁后，经临界区访问到R，完了释放锁。需了解LR和R的联系 。要明确用哪个锁保护哪个资源！（管程的博客） java-管程系列1-synchronized1234567891011121314151617181920class X &#123; // 修饰非静态方法（this） synchronized void foo() &#123; // 临界区 &#125; // 修饰静态方法（Class） synchronized static void bar() &#123; // 临界区 &#125; // 修饰代码块 Object obj = new Object()； void baz() &#123; synchronized(obj) &#123; // 临界区 &#125; &#125;&#125; 当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；当修饰非静态方法的时候，锁定的是当前实例对象 this。为什么看不到加锁，解锁的操作？因为jvm封装了Mintor来操作synchronized关键字，自动实现加锁和释放锁操作。 解决count+=112345678910class SafeCalc &#123; long value = 0L; long get() &#123; return value; &#125; synchronized void addOne() &#123; value += 1; &#125;&#125;被synchronized修饰后，无论是在单核还是多核都有且仅会有一个线程能执行addOne方法，原子性解决了。但是有么有解决可见性？ 管程中锁的规则：对一个锁的解锁happens-Before于后续对这个锁的加锁12简单说就是：前一个线程的解锁操作对后一个线程的加锁操作是可见的！但是此时，不小心在addOne 10000次的情况下动了get方法，那么这个时候get方法的可见性并不能保证。怎么解决？ 123456789class SafeCalc &#123; long value = 0L; synchronized long get() &#123; return value; &#125; synchronized void addOne() &#123; value += 1; &#125;&#125; 1转换成模型：此时get和addOne 是互斥的。还可以哈！ 锁和保护资源的关系1资源：锁 N:1挺好，现实生活中多个锁保护一个资源，但是并发领域会发生死锁等多个问题！把上面的代码中addOne方法改成static修饰！ 1234567891011121314class SafeCalc &#123; static long value = 0L; synchronized long get() &#123; return value; &#125; synchronized static void addOne() &#123; value += 1; &#125;&#125;get()是用的this，addOne()是用的SafeCalc.class，那么问题来了，你addOne修改了value的值，我get并不知道，可见性并不存在！NO所以说互斥这个东西贼鸡儿重要（爽）！ 不错！下面来看怎么用一把锁保护多个资源以及相关问题！保护没有关联关系的多个资源对账户余额和账户密码的保护1234567891011121314151617181920212223242526272829303132333435363738394041class Account &#123; // 锁：保护账户余额 private final Object balLock = new Object(); // 账户余额 private Integer balance; // 锁：保护账户密码 private final Object pwLock = new Object(); // 账户密码 private String password; // 取款 void withdraw(Integer amt) &#123; synchronized(balLock) &#123; if (this.balance &gt; amt)&#123; this.balance -= amt; &#125; &#125; &#125; // 查看余额 Integer getBalance() &#123; synchronized(balLock) &#123; return balance; &#125; &#125; // 更改密码 void updatePassword(String pw)&#123; synchronized(pwLock) &#123; this.password = pw; &#125; &#125; // 查看密码 String getPassword() &#123; synchronized(pwLock) &#123; return password; &#125; &#125;&#125;上述用balLock和pwLock来分别保护，当然可以使用同一个this来保护，但是性能太差都是变成串行操作了。贼慢！ 用多个锁对受保护资源进行精细化管理，能够提升性能美名其曰：细粒度锁。1保护有关联的多个资源：账户A-&gt;B(100)?代码化：Account(账户),成员变量：balance，transfer()怎么没有并发问题？ 12345678910111213141516171819202122232425class Account &#123; private int balance; // 转账 void transfer( Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125;正确？不正确加上synchronized正确？class Account &#123; private int balance; // 转账 synchronized void transfer( Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; 1234不正确synchronized只能锁住this.balance并不能锁住target.balance。假设A,B,C三个账户里面都有300块钱。A转账B 100，B转给C 100。期望是A还有200，B还是300，C 400块。假设线程1完成A-&gt;B,线程2完成B-&gt;C分别在两个不同的CPU上执行，但是他们并不互斥。怎么解决？ 使用一把锁覆盖所有的资源！12345678910111213141516171819class Account &#123; private Object lock； private int balance; private Account(); // 创建 Account 时传入同一个 lock 对象 public Account(Object lock) &#123; this.lock = lock; &#125; // 转账 void transfer(Account target, int amt)&#123; // 此处检查所有对象共享的锁 synchronized(lock) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125;&#125; 12此时私有private Object lock，创建构造函数每一次都传入同一个对象lock。可以保证并发问题，但是在真实项目中多个工程中实现每次传入的lock都是同一个有点复杂（其实队列可以好好使用）还有就是使用Account.class作为锁。 1总结：解决原子问题就是解决操作的中间状态对外不可见！]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2-JMM浅谈]]></title>
    <url>%2F2019%2F03%2F10%2Fjavacurrent2%2F</url>
    <content type="text"><![CDATA[java内存模型 var ap = new APlayer({ element: document.getElementById("aplayer-NxrOotRw"), narrow: false, autoplay: true, showlrc: false, music: { title: "恋爱循环", author: "香菜", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/花澤香菜 - 恋愛サーキュレーション.mp3", pic: "http://p1.music.126.net/hWrYLdhzF4waj4WL1dFPmg==/642114790633458.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 1.导致可见性的原因是缓存：12有序性的原因是编译优化，合理的方案应该是“按需禁用缓存和编译优化”。java的内存模型是个很复杂的规范，从程序员的角度：java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法-&gt;volatile,synchronized,final三个关键字，以及六项Happens-Before规则。 2-volatile123456789101112131415161718192021222324252627282930313233volatile int x=1;//告诉编译器对这个x变量的读写不能使用CPU缓存，必须从内存中读或者写，但是实际运用中的困惑却很多！public class VolatileExample &#123; int x = 0; volatile boolean v = false; public void writer() &#123; x = 42; v = true; &#125; public void reader() &#123; if (v) &#123; System.out.println(&quot;x = &quot; + x); &#125; &#125;&#125;class Test &#123; public static void main(String[] args) throws InterruptedException &#123; VolatileExample volatileExample = new VolatileExample(); Thread A = new Thread(volatileExample::writer); Thread B = new Thread(volatileExample::reader); A.start(); B.start(); A.join(); B.join(); &#125;&#125;//x = 42解释：线程A执行writer方法，安装volatile语义会把变量“v=true”写到内存中，此时线程B执行reader方法，线程B会从内存中读取变量V，此时x结果为42。（java版本必须保证在1.5之后）JAVA1.5解决了CPU缓存导致可见性问题，Happens-Before规则。Happens-Before：前面一个操作的结果对后续的操作是可见的。约束了编译器的优化的行为，编译器优化必须遵循Happens-Before原则（6个原则）。 1.程序代码片段的顺序性规则 12345678910111213141516// 以下代码来源于【参考 1】1class VolatileExample &#123; 2 int x = 0; 3 volatile boolean v = false; 4 public void writer() &#123; 5 x = 42; //对x进行赋值 写 6 v = true;//对v进行赋值 写 7 &#125; 8 public void reader() &#123; 9 if (v == true) &#123;//此时需要读v 10 // 这里 x 会是多少呢？ 11 &#125; &#125;&#125;代码第5行x=42，对于第6行v=true来讲是可见的。（规则1）称之5 happens-before于6 2.Volatile变量规则1对一个volatile编写的写操作happens-before于后续对这个volatile变量的读操作。（在不关联3的时候，就是禁用缓存的意思。） 3.传递性A happens-before B，&amp; B happens-before C，那么A happens-before C。123x=42 happens-before v=true的写操作 规则1：程序的顺序性v=true 写操作 happens-before v=true的读操作 规则2 ： volatile修饰变量的可见性那么根据规则3 x=42 happens-before v=true的读操作！此时线程B能看到线程A中的x=42！ 4.管程中的锁–对一个锁的解锁 happens-before 于后续对这个锁的加锁。12管程：一种通用的同步原语-java实现synchronized（此过程的加锁释放锁（代码块执行完&#125;后）都是jvm帮我们实现的 底层：javap monitor机制）。 5.线程start规则1主线程A在启动子线程B后，子线程B能够看到主线程A再启动B前的操作。 6.线程join规则123456789101112131415指主线程A等待子线程B完成（A调用子线程B的join方法实现），当B完成操作后，主线程A能够看到B对共享变量的操作。Thread B = new Thread(()-&gt;&#123; // 此处对共享变量 var 修改 var = 66;&#125;);// 例如此处对共享变量修改，// 则这个修改结果对线程 B 可见// 主线程启动子线程B.start();B.join()// 子线程所有对共享变量的修改// 在主线程调用 B.join() 之后皆可见// 此例中，var==66假设B在线程A中执行，那么B中对变量var的修改 happens-before A,就是A都知道。 7.线程中断规则：12对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 8.对象终结规则：12345678910111213一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。final：修饰变量的时候，告诉编译器，这个变量生而不变（内地地址）。在正确的构造函数中没有“逸出”就不会出现问题！// 以下代码来源于【参考 1】final int x;// 错误的构造函数public FinalFieldExample() &#123; x = 3; y = 4; // 此处就是讲 this 逸出， global.obj = this;&#125; 思考：此时有可能访问到this还没有初始化完成！问题：一个共享变量a=3,在一个线程中设置了abc的值a=3，怎么让其他线程看到？跳出这个圈子–其实就是怎么解决缓存问题12341-volatile 修饰a2-加锁synchronized ，根据 happens-before 原则其他线程在A线程释放锁以后就会看到变量a3-A线程启动后使用A.join(),后续线程就可以看到4-直接使用static修饰]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1-学习java并发]]></title>
    <url>%2F2019%2F03%2F10%2Fjavacurrent1%2F</url>
    <content type="text"><![CDATA[导语：把握关键的6秒时差并发的学习不是简单的一两天能解决的，需要长期的学习，运用，总结。加油！大纲 ： var ap = new APlayer({ element: document.getElementById("aplayer-IlwRwrpk"), narrow: false, autoplay: true, showlrc: false, music: { title: "只想要你知道", author: "鬼卞", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/%E5%8F%AA%E6%83%B3%E8%A6%81%E4%BD%A0%E7%9F%A5%E9%81%93.mp3", pic: "http://p2.music.126.net/6cxatxCqTNVhS4YcT5wGFQ==/109951163172559495.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 简单介绍：分工，同步，互斥分工12任务分解：多线程实现。Java SDK中Executor,Fork/Join ,Future。模式：生产-消费者，Worker-Thread(spark集群)，Thread-Per-Message。（合理的结合生活场景。） 同步12一个线程完成了一个任务，如何通知后续的任务线程开工。Future,CountDownLatch、CyclicBarrier、Phaser、Exchanger。核心是管程。 互斥123分工，同步解决的是性能问题。互斥讲的是线程安全问题--同一时刻只允许一个线程访问共享变量。JAVA：synchronized，lock；Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能，CAS更好！不共享变量或者只允许读：ThreadLocal，final，Copy-on-Write模式。 可见性，原子性，有序性就是并发的源头12并发(concurrency)：1:在同一时间间隔内，一个cpu,轮流执行多个任务(线程)。并行(parallellism)：1:讲究同时性--多个cpu同时执行多个任务(线程)。 并发程序之幕后123456789CPU,内存，I/O三者的速度差异-&gt;核心矛盾CPU&gt;&gt;内存&gt;&gt;I/O（天-&gt;年-&gt;1000年）程序中大部分代码会涉及访问操作系统内存+I/O，根据木桶理论(最短的那块板子，决定了一只木桶能装多少水！)，所以整个程序的性能取决于I/O读写操作。仅单方面提高CPU性能是无效的。目前合理利用CPU性能，平衡这三者的速度差异，计算机体系机构，操作系统，编译程序分别作了： 1.CPU增加了缓存-&gt;均衡了与内存的速度差异！ 2.操作系统增加了进程、线程分时复用CPU，为了均衡CPU和I/O的速度差异。 3.编译程序优化了指令执行次序，使得缓存能够得到更加合理的使用。 核心矛盾就是并发程序的诡异问题的根源！ 一、CPU缓存导致的可见性问题1单核CPU缓存和内存的数据一致性问题很好解决！下图CPU和内存的关系图！ 1234可见性：一个线程对共享变量的修改，另外一个线程能立刻看到！单核CPU上多个线程操作同一个CPU的缓存，一个线程对缓存的写，对另一个线程来说一定是可见的。上图：线程A和B同时操作同一个CPU的缓存，所以A更新了V的值，B之后再访问一定是拿到的最新的值。多核CPU,每个cpu都有自己的缓存！ 1234567891011121314151617181920212223242526272829此时A线程操作的是CPU-1上的缓存，B线程操作的是CPU-2上面的缓存，A线程对变量V的操作对于B线程来讲就是隐藏的。public class Test &#123; private long count = 0; private void add10K() &#123; int idx = 0; while(idx++ &lt; 10000) &#123; count += 1; &#125; &#125; public static long calc() &#123; final Test test = new Test(); // 创建两个线程，执行 add() 操作 Thread th1 = new Thread(()-&gt;&#123; test.add10K(); &#125;); Thread th2 = new Thread(()-&gt;&#123; test.add10K(); &#125;); // 启动两个线程 th1.start(); th2.start(); // 等待两个线程执行结束 th1.join(); th2.join(); return count; &#125;&#125;执行calc()方法会发现，打印结果小于20000，因为A，B两个线程启动的时候会被放到不同的CPU中执行，而此时只有一个内存，A从内存中把count读出来放到cpu缓存中+1,B也是这样，完了再把count放到内存中。当A,B线程同时发生的时候，会发现内存中的值为1，而不是我们期望的2。 二、线程切换-带来原子性问题1.例如单核CPU电脑上可以边听歌，边写bug，因为多进程存在的原因。1单核操作系统允许某个进程A执行一段时间-50ms，过了50ms会重新选择一个进程B来执行（线程切换），此时A线程不占有CPU，这个50ms叫做“时间片”。 2.Unix解决了？支持多进程分时复用–IO操作释放CPU，让CPU去做其他的任务！1234567891011121314前面提到CPU的速度&gt;&gt;I/O,当在一个时间片中，一个进程进行一个I/O操作的时候（读取一个文件），这个时候CPU发出一个指令就可以，但是I/O操作还会持续把文件读进内存，如果这个时候这个进程还在占有该CPU那么对于此时来讲，这个CPU是浪费的。可以在此时，该进程把自己标记为“休眠状态”并且让出CPU占有权，直到文件被读进内存后，操作系统唤起该进程，该进程可以继续获取到CPU的使用权。那么CPU发出一个指令直到文件被读进内存期间，CPU使用权被释放，那么CPU可以做别的事情了，CPU的使用率会提高；此外，如果这个时候有另外一个进程也在进行读取文件，那么这个读取文件的进程就会排队，磁盘驱动在完成上一个读操作后，发现有新的任务，则会立即启动下一个读进程，此时IO的使用率也会提高。早期的操作系统都是基于进程来调度CPU的，不同进程之间是不共享内存空间的，进程之间的任务切换就是切换内存映射地址。而一个进程所创建的所有的线程都是共享同一个内存空间的，SO,Thread之间进行任务切换就很低的成本了，现在的操作系统基本都是基于线程切换。JAVA并发程序都是基于多线程的，存在线程切换。java属于高级语言，代码中的一条语句往往需要多条CPU指令执行。count+=1;则需要3条CPU指令。1.把count从内存中加载到CPU寄存器。2.在寄存器中执行+1操作3.把此时count的结果写到内存中（也有可能写到CPU缓存）此时的任务切换可能发生在任意CPU指令执行后，而不是java中一句代码后。 123如图：线程切换会造成count+=1原子性问题。结果是1，不是期望的2.原子性：一个或者多个操作在CPU执行的过程中不被中断的特性。大头？如何在高级语言层面保证操作的原子性？ 三、编译优化带来的有序性问题。1234567891011121314151617181920212223242526272829编译器为了优化性能，会改变程序中语句的先后顺序。“a=6;b=7”会变成&quot;b=7;a=6&quot;这个不会影响程序的最终结果，但是下面：会有问题双重检查创建单例对象：public class Singleton &#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125;1：首先判断instance==null？是，则锁住Singleton.class并且再次检查instance==null？是，则创建Singleton的一个实例。A,B两个线程同时调用getInstance方法，他们同时发现instance==null，于是同时对Singleton.class加上锁,但此时JVM保证只会有一个线程加锁成功（假设是A），B则会等待。A会创建一个Singleton实例，之后释放锁，B会被唤醒，B会尝试加锁，此时会成功加锁，线程B检查instance==null会发现已经存在了Singleton实例则不会再创建。但是new操作的时候会出现问题！我们期望：1：分配一块内存M2：在内存M上初始化Singleton对象3：然后M的地址值赋给instance变量实际上：经过编译优化后！1：分配一块内存M2：把M的地址值赋值给instance对象3：最后在M上初始化SingletonA线程在完成“把M的地址值赋值给instance对象”这一指令之后就直接线程切换给了B线程，然后B线程判断instance！=null（此时都没有进入synchronized里面）但是，此时instance会有空指针异常！ 问题12long类型在32位操作系统上不安全？答案：long64位，所以在32位机器上对long类型的数据操作是由多条CPU指令组合来的，无法保持原子性。]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
</search>
