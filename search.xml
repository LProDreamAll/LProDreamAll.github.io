<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[6-为什么局部变量是线程安全的？并发之面向对象！]]></title>
    <url>%2F2019%2F03%2F28%2Fjavacurrentcode1%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-soIUuMnv"), narrow: false, autoplay: true, showlrc: false, music: { title: "画师", author: "梅粮新", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/%E6%A2%85%E7%B2%AE%E6%96%B0%20-%20%E7%94%BB%E5%B8%88.mp3", pic: "http://p1.music.126.net/FPLF1xShAN9dMkrTNfnLlg==/109951163926963485.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 没有什么是不累的。没有什么是不难的。鹰击长空,鱼翔浅底。为什么局部变量是线程安全的？并发之面向对象！为什么局部变量是线程安全的？123456789101112131415161718// 返回斐波那契数列int[] fibonacci(int n) &#123; // 创建结果数组 int[] r = new int[n]; // 初始化第一、第二个数 r[0] = r[1] = 1; // ① // 计算 2..n for(int i = 2; i &lt; n; i++) &#123; r[i] = r[i-2] + r[i-1]; &#125; return r;&#125;上述代码局部变量数组r并不会存在数据竞争。。。首先在CPU层面是没有方法概念的，只有一条条的指令，编译程序负责把高级语言中方法转换成一条条指令。如下：int a = 7；int[] b = fibonacci(a);int[] c = b;第一行声明一个变量a，2调用方法fibonacci(a)，3把b赋值给c。 1234当调用fibonacci(a)的时候，CPU要先找到方法的地址，然后跳转到这个地址执行代码，执行完fibonacci(a)方法要能够返回。然后找到int[] c = b的地址，再跳到这个地址去执行。。CPU通过CPU的堆栈寄存器找到方法参数和返回地址。CPU支持调用栈（先进后出！）A,B,C:A-&gt;B-&gt;C。每个方法在调用栈里都有自己的独立空间，称为栈帧。每个栈帧里面都有对应方法需要的参数和返回地址。当调用方法时会创建新的栈帧，并压入调用栈，当方法返回时候，对应的栈帧就会被自动弹出。栈帧和方法同存活。 1局部变量的作用域是方法内部，和方法同生死，和栈帧同生死-&gt;局部变量被放到了调用栈里。SO: 123每个线程都有自己的独立栈，从而没有线程安全问题。线程封闭出现了：仅仅在单线程内访问数据，由于不存在共享所以不同步也没有问题。java中数据库连接connection一旦被一个线程获取后在这个线程关闭connection这段时间内将不会被其他线程获取，so灭有问题。 并发之面向对象！封装共享变量1234567891011将共享变量作为对象属性封装在内部，对所有的能访问到的涉及到共享变量的公共方法指定并发的访问策略。public class Counter &#123; private long value; synchronized long get()&#123; return value; &#125; synchronized long addOne()&#123; return ++value; &#125;&#125;Counter是个线程安全的类。工作中经常使用final。 识别共享变量之间的约束条件12345678910111213141516171819下面的代码灭有线程安全问题public class SafeWM &#123; // 库存上限 private final AtomicLong upper = new AtomicLong(0); // 库存下限 private final AtomicLong lower = new AtomicLong(0); // 设置库存上限 void setUpper(long v)&#123; upper.set(v); &#125; // 设置库存下限 void setLower(long v)&#123; lower.set(v); &#125; // 省略其他业务代码&#125;库存管理中有个合理库存概念，有上下限。所以上面的代码需要修改一下： 123456789101112131415161718192021222324252627public class SafeWM &#123; // 库存上限 private final AtomicLong upper = new AtomicLong(0); // 库存下限 private final AtomicLong lower = new AtomicLong(0); // 设置库存上限 void setUpper(long v)&#123; // 检查参数合法性 if (v &lt; lower.get()) &#123; throw new IllegalArgumentException(); &#125; upper.set(v); &#125; // 设置库存下限 void setLower(long v)&#123; // 检查参数合法性 if (v &gt; upper.get()) &#123; throw new IllegalArgumentException(); &#125; lower.set(v); &#125; // 省略其他业务代码&#125;假设库存[2,10],但是这个时候A-&gt;setUpper(5),B-&gt;setLower(7)假设A,B同时发生A中5&gt;2,B中7&lt;10可以。而此时的逻辑则不正确。所以改成： 12345678910111213141516171819202122232425262728293031323334public class SafeWM &#123; // 库存上限 private final AtomicLong upper = new AtomicLong(0); // 库存下限 private final AtomicLong lower = new AtomicLong(0); // 设置库存上限 void setUpper(long v) &#123; // 检查参数合法性 synchronized (this) &#123; if (v &gt;= lower.get()) &#123; upper.set(v); &#125; else &#123; throw new IllegalArgumentException(); &#125; &#125; &#125; // 设置库存下限 void setLower(long v) &#123; // 检查参数合法性 synchronized (this) &#123; if (v &lt;= upper.get()) &#123; lower.set(v); &#125; else &#123; throw new IllegalArgumentException(); &#125; &#125; &#125; // 省略其他业务代码&#125;此时线程是安全的，业务也满足了。嘘嘘嘘(松一口气!) 递归调用太深会导致栈内存溢出？123原因：每次调用一次就会有新的栈帧出现，栈帧是消耗内存的。1-所有递归方法都可以使用非递归实现2-合理设置栈的大小]]></content>
      <categories>
        <category>JAVA并发之代码设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6-为什么局部变量是线程安全的？并发之面向对象！]]></title>
    <url>%2F2019%2F03%2F28%2Fjavacurrent6%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-RHXrysDt"), narrow: false, autoplay: true, showlrc: false, music: { title: "画师", author: "梅粮新", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/%E6%A2%85%E7%B2%AE%E6%96%B0%20-%20%E7%94%BB%E5%B8%88.mp3", pic: "http://p1.music.126.net/FPLF1xShAN9dMkrTNfnLlg==/109951163926963485.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 没有什么是不累的。没有什么是不难的。鹰击长空,鱼翔浅底。为什么局部变量是线程安全的？并发之面向对象！为什么局部变量是线程安全的？123456789101112131415161718// 返回斐波那契数列int[] fibonacci(int n) &#123; // 创建结果数组 int[] r = new int[n]; // 初始化第一、第二个数 r[0] = r[1] = 1; // ① // 计算 2..n for(int i = 2; i &lt; n; i++) &#123; r[i] = r[i-2] + r[i-1]; &#125; return r;&#125;上述代码局部变量数组r并不会存在数据竞争。。。首先在CPU层面是没有方法概念的，只有一条条的指令，编译程序负责把高级语言中方法转换成一条条指令。如下：int a = 7；int[] b = fibonacci(a);int[] c = b;第一行声明一个变量a，2调用方法fibonacci(a)，3把b赋值给c。 1234当调用fibonacci(a)的时候，CPU要先找到方法的地址，然后跳转到这个地址执行代码，执行完fibonacci(a)方法要能够返回。然后找到int[] c = b的地址，再跳到这个地址去执行。。CPU通过CPU的堆栈寄存器找到方法参数和返回地址。CPU支持调用栈（先进后出！）A,B,C:A-&gt;B-&gt;C。每个方法在调用栈里都有自己的独立空间，称为栈帧。每个栈帧里面都有对应方法需要的参数和返回地址。当调用方法时会创建新的栈帧，并压入调用栈，当方法返回时候，对应的栈帧就会被自动弹出。栈帧和方法同存活。 1局部变量的作用域是方法内部，和方法同生死，和栈帧同生死-&gt;局部变量被放到了调用栈里。SO: 123每个线程都有自己的独立栈，从而没有线程安全问题。线程封闭出现了：仅仅在单线程内访问数据，由于不存在共享所以不同步也没有问题。java中数据库连接connection一旦被一个线程获取后在这个线程关闭connection这段时间内将不会被其他线程获取，so灭有问题。 并发之面向对象！封装共享变量1234567891011将共享变量作为对象属性封装在内部，对所有的能访问到的涉及到共享变量的公共方法指定并发的访问策略。public class Counter &#123; private long value; synchronized long get()&#123; return value; &#125; synchronized long addOne()&#123; return ++value; &#125;&#125;Counter是个线程安全的类。工作中经常使用final。 识别共享变量之间的约束条件12345678910111213141516171819下面的代码灭有线程安全问题public class SafeWM &#123; // 库存上限 private final AtomicLong upper = new AtomicLong(0); // 库存下限 private final AtomicLong lower = new AtomicLong(0); // 设置库存上限 void setUpper(long v)&#123; upper.set(v); &#125; // 设置库存下限 void setLower(long v)&#123; lower.set(v); &#125; // 省略其他业务代码&#125;库存管理中有个合理库存概念，有上下限。所以上面的代码需要修改一下： 123456789101112131415161718192021222324252627public class SafeWM &#123; // 库存上限 private final AtomicLong upper = new AtomicLong(0); // 库存下限 private final AtomicLong lower = new AtomicLong(0); // 设置库存上限 void setUpper(long v)&#123; // 检查参数合法性 if (v &lt; lower.get()) &#123; throw new IllegalArgumentException(); &#125; upper.set(v); &#125; // 设置库存下限 void setLower(long v)&#123; // 检查参数合法性 if (v &gt; upper.get()) &#123; throw new IllegalArgumentException(); &#125; lower.set(v); &#125; // 省略其他业务代码&#125;假设库存[2,10],但是这个时候A-&gt;setUpper(5),B-&gt;setLower(7)假设A,B同时发生A中5&gt;2,B中7&lt;10可以。而此时的逻辑则不正确。所以改成： 12345678910111213141516171819202122232425262728293031323334public class SafeWM &#123; // 库存上限 private final AtomicLong upper = new AtomicLong(0); // 库存下限 private final AtomicLong lower = new AtomicLong(0); // 设置库存上限 void setUpper(long v) &#123; // 检查参数合法性 synchronized (this) &#123; if (v &gt;= lower.get()) &#123; upper.set(v); &#125; else &#123; throw new IllegalArgumentException(); &#125; &#125; &#125; // 设置库存下限 void setLower(long v) &#123; // 检查参数合法性 synchronized (this) &#123; if (v &lt;= upper.get()) &#123; lower.set(v); &#125; else &#123; throw new IllegalArgumentException(); &#125; &#125; &#125; // 省略其他业务代码&#125;此时线程是安全的，业务也满足了。嘘嘘嘘(松一口气!) 递归调用太深会导致栈内存溢出？123原因：每次调用一次就会有新的栈帧出现，栈帧是消耗内存的。1-所有递归方法都可以使用非递归实现2-合理设置栈的大小]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5-线程的生命周期？线程创建的条数？]]></title>
    <url>%2F2019%2F03%2F25%2Fjavacurrent5%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-eqxlgwGr"), narrow: false, autoplay: true, showlrc: false, music: { title: "个人简介", author: "安全着陆", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/%E5%AE%89%E5%85%A8%E7%9D%80%E9%99%86%20-%20%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B.mp3", pic: "http://p2.music.126.net/thXkupdKJtuSswDv4u-sow==/68169720928612.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 少喝酒！线程的生命周期？线程创建的条数？线程的生命周期1初始状态、可运行状态、运行状态、休眠状态和终止状态 1:初始状态1线程在编程语言层面创建，在操作系统层面并没有被创建 2:可运行状态1线程可以分配CPU执行，此时，在操作系统中线程已经被创建了，可以分配CPU执行 3:运行状态1CPU有空闲时，操作系统会分配给一个线程，此时线程的状态变成了运行状态 4:休眠状态1运行状态的线程如果调用一个堵塞的API，那么线程就会变成休眠状态。同时释放CPU资源，当等待的事件出现了以后才会转换到可运行状态。 5:终止状态1执行完或者出现异常都会进入终止状态，此时生命周期结束了。 java中线程的生命周期1234567jvm封装了运行和可运行状态！1:NEW(初始状态)2:RUNNABLE(可运行状态&amp;&amp;运行状态)3:BLOCK(堵塞状态)4:WAITING(无限时等待)5:TIMED_WAITING(有限时等待)6:TERMINATED（终止状态) RUNNABLE-&gt;BLOCK12synchronized修饰的代码块：多个线程同时访问是等待隐式锁才会等待。调用堵塞API时，操作系统的线程是堵塞状态，但是java的线程状态是RUNNABLE。 RUNNABLE-&gt;WAITING123451:获得synchronized隐式锁的线程调用Object.wait()2:THread.join().main中执行A，调用A.join():main线程需要等待A线程执行完。此时main线程由RUNNABLE-&gt;WAITING，A完成，mian-&gt;RUNNABLE3:LockSupport.park()调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITIN调用 LockSupport.unpark(Thread thread)则相反 RUNNABLE-&gt;TIMED_WAITING(多了个超时参数)123451:Thread.sleep(long millis)2:Object.wait(long timeout) 方法3:Thread.join(long millis) 方法4:LockSupport.parkNanos(Object blocker, long deadline)5:LockSupport.parkUntil(long deadline) NEW-&gt;RUNNABLE1234567891011121314// 自定义线程对象class MyThread extends Thread &#123; public void run() &#123; // 线程需要执行的代码 ...... &#125;&#125;// 创建线程对象MyThread myThread = new MyThread();MyThread myThread = new MyThread();// 从 NEW 状态转换到 RUNNABLE 状态myThread.start()； RUNNABLE-&gt;TERMINATED1234561-执行完run()2-线程执行时抛出异常3-stop()//已经不再使用4-interrupt()其他线程可以调用interrupt()用来阻断别的线程。isInterrupted可以判断是否被自己中断了 线程中断后退出while的循环123456789101112131415Thread th = Thread.currentThread();while(true) &#123; if(th.isInterrupted()) &#123; break; &#125; // 省略业务代码无数 try &#123; //此处sleep期间会抛出异常，那么就会一直循环 Thread.sleep(100); &#125;catch (InterruptedException e)&#123; //此处应该手动中断线程 Thread.currentThread().interrupt(); e.printStackTrace(); &#125;&#125; 线程创建的条数为什么要使用多线程？12341-降低延迟发出请求到收到响应的时间2-提高吞吐量单位时间内处理请求的数量 多线程的应用场景12‘降低延迟，提高吞吐量’-&gt;1算法优化 2将硬件的性能发挥到极致在并发领域中就是提高硬件的利用率：提升I/O的利用率和CPU的利用率。 如何提高？1假设线程按照CPU计算和I/O操作交叉执行的方式运行，且耗时都是1:1.如图那么，CPU和I/O的利用率都是50% 1如果有两个线程按照A-&gt;CPU,B-&gt;I/O。A-&gt;I/O,B-&gt;CPU。那么CPU和I/O的利用率都是100% 1当CPU和I/O利用率都比较低可以选择多线程来增加利用率。 123对于CPU密集型：多线程就是为了提升多核CPU的利用率，一般是CPU核数+1个线程数。因为当一个线程出现问题时候，这个线程可以马上顶上！对于I/O密集型，CPU：I/O = 1：n -&gt; 可以是 (n+1)个线程最合适，多核CPU-&gt;(n+1)*CPU核数最佳]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4-死锁（互斥，占有且等待，不可抢占，循环等待）]]></title>
    <url>%2F2019%2F03%2F25%2Fjavacurrent4%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-sJTibYCx"), narrow: false, autoplay: true, showlrc: false, music: { title: "皇后大道东", author: "罗大佑", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/%E8%92%8B%E5%BF%97%E5%85%89%2C%E7%BD%97%E5%A4%A7%E4%BD%91%20-%20%E7%9A%87%E5%90%8E%E5%A4%A7%E9%81%93%E4%B8%9C.mp3", pic: "http://p2.music.126.net/thXkupdKJtuSswDv4u-sow==/68169720928612.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); Stay Hunger , Stay Young那怎么解决死锁问题？1前面说了可以使用Account.class作为锁但是这就造成了整个操作变成了串行了。那么性能完全不能接受。下面进行优化！ 优化1234具体操作就是在转账的过程中增加转入和转出账本！1：恰好有转入和转出账本的时候，同时拿走可以进行转账操作。2：当只有一个账本的时候那就拿走这个账本，等另一个账本被用过。3：都没有就等两个账本出现。 123456789101112131415161718192021222324252627282930代码实现class Account &#123; private int balance; // 转账 void transfer(Account target, int amt)&#123; // 锁定转出账户 synchronized(this) &#123; // 锁定转入账户 synchronized(target) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; &#125;但是会出现死锁问题：用户A想要从A-&gt;B 100元，拿到账户A转出的账本。恰恰这个时候用户B想要转给A。拿到了B的转出账本，而他俩进行下一步的条件都是需要等对方把账本归还，那就等到死，都等不到。。。。于是死锁出现了：一组互相竞争资源的线程因为互相等待，导致永久堵塞的现象。如何避免死锁？Coffman的大神总结只有下面四个条件同时发生的时候才会出现死锁问题：1：互斥，共享资源X，Y只能被一个线程占用2：占有且等待：线程T1占有X资源的时候，再等待资源Y的时候，并没有释放资源X3：不可抢占：其他的线程不能抢占T1的资源4：循环等待：T1等待T2的资源，T2等待T1的资源1一般不会打破，只能从2,3,4下手。2：一次性申请所有资源3：占有资源的线程进一步占有其他资源的时候，如果获取不到，可以主动释放他占有的资源。4：按序申请资源，多个线程申请的时候可以先申请资源序号小的，再申请大的，这样就不存在循环了。 占有且等待的破坏（一次性申请所有资源）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667增加管理员：当只有一个账本的时候并不给转账，只有两个转入和转春都存在的时候才能给转账！这样才能保证“一次性申请所有资源”编码的时候需要增加Allocator ：具有同时申请apply()和同时释放资源free(),在Accout类中Allocator必须是单例的。public class Allocator &#123; private List&lt;Object&gt; als = new ArrayList&lt;&gt;(); // 一次性申请所有资源 synchronized boolean apply( Object from, Object to)&#123; if(als.contains(from) || als.contains(to))&#123; return false; &#125; else &#123; als.add(from); als.add(to); &#125; return true; &#125; // 归还资源 synchronized void free( Object from, Object to)&#123; als.remove(from); als.remove(to); &#125; private Allocator() &#123; if (SingletonHolder.instance != null) &#123; throw new IllegalStateException(); &#125; &#125; private static class SingletonHolder &#123; private static Allocator instance = new Allocator(); &#125; public static Allocator getInstance() &#123; return SingletonHolder.instance; &#125;&#125;class Account &#123; // actr 应该为单例 private Allocator actr = Allocator.getInstance(); private int balance; // 转账 void transfer(Account target, int amt)&#123; // 一次性申请转出账户和转入账户，直到成功 //这里会占用大量资源 while(!actr.apply(this, target)); try&#123; // 锁定转出账户 synchronized(this)&#123; // 锁定转入账户 synchronized(target)&#123; if (this.balance &gt; amt)&#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125; finally &#123; actr.free(this, target); &#125; &#125;&#125; 破坏不可抢占条件1java层面并没有解决这个问题但是jdk层面解决了java.util.concurrent包下的Lock解决了后面聊 破坏循环等待条件12345678910111213141516171819202122232425对资源进行排序，按照序号申请资源，给每个账户设置不同的id，然后给id排序进行申请。代码如下：class Account &#123; private int id; private int balance; // 转账 void transfer(Account target, int amt) &#123; Account left = this; Account right = target; if (this.id &gt; target.id) &#123; left = target; right = this; &#125; // 锁定序号小的账户 synchronized (left) &#123; // 锁定序号大的账户 synchronized (right) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; &#125;&#125; synchronized 实现等待-通知机制123456优化破坏占有等待条件,while(!actr.apply(this, target));这个方法在真实高并发项目中并不行。当循环上万次才能得到正确的结果的时候就不行了。正确的优化思路应该是：如果线程要求的条件（转入和转出账本并不在同一个文件架中，并不能一次获取两个），则这个线程就该堵塞自己（zookeeper中集群模式有点这个味道）进入等待状态;当线程要求的条件满足了，通知那个等待的线程重新执行，那么使用线程堵塞的方式就能避免循环等待消耗CPU的问题。wait(),notify(),notifyAll() //都是Object类中的方法如图：wait()操作的原理图 12345一个线程进入synchronized保护的临界区后，其他的线程只能在左面的等待队列中进行等待。这个等待队列和互斥锁是一对一关系，每个互斥锁都有自己独立的等待队列。那么当条件满足后怎么唤醒呢？使用notify(随机唤起，会造成有些线程永远不会被唤醒。只是保证在通知的时间点，条件是满足的，当其他线程插队时，被通知线程的执行时间点和通知时间点基本上不会重合，所以很大几率会唤醒失败！)，notifyAll（唤醒所有的线程）。如果synchronized锁住的是this那么一定是this.wait...，若果锁住的是target，那就是target.wait() 好的资源分配器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647互斥锁：this线程要求的条件：转出账户和转入账户都没有被分配过何时等待：线程要求的条件不满足就等待何时通知：当有线程释放账户的时候就进行通知。伪代码如下： while(条件不满足) &#123; wait(); &#125;代码实现：public class Allocator &#123; private List&lt;Object&gt; als; // 一次性申请所有资源 synchronized void apply( Object from, Object to)&#123; // 经典写法 while(als.contains(from) || als.contains(to))&#123; try&#123; wait(); &#125;catch(Exception e)&#123; &#125; &#125; als.add(from); als.add(to); &#125; // 归还资源 synchronized void free( Object from, Object to)&#123; als.remove(from); als.remove(to); notifyAll(); &#125; private Allocator() &#123; if (SingletonHolder.instance != null) &#123; throw new IllegalStateException(); &#125; &#125; private static class SingletonHolder &#123; private static Allocator instance = new Allocator (); &#125; public static Allocator getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 思考1其实有点类似封装的概念把两个账本都拿到封装成一个操作，那对外部来讲就是原子性操作。但是要保证拿到两个账本的操作一定封装成了一个操作！ 123456wait与sleep区别在于：1. wait会释放所有锁而sleep不会释放锁资源.2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以.3. wait无需捕捉异常，而sleep需要.两者相同点：都会让渡CPU执行时间，等待再次调度！ 总结123synchronized(Account.class)和while(!actr.apply(this, target));的区别！synchronized(Account.class) 锁了Account类相关的所有操作。相当于文中说的包场了，只要与Account有关联，通通需要等待当前线程操作完成。while死循环的方式只锁定了当前操作的两个相关的对象。两种影响到的范围不同。]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3-原子性问题的由来、资源如何保护]]></title>
    <url>%2F2019%2F03%2F23%2Fjavacurrent3%2F</url>
    <content type="text"><![CDATA[var ap = new APlayer({ element: document.getElementById("aplayer-cUCAcKIw"), narrow: false, autoplay: true, showlrc: false, music: { title: "鸦雀无声", author: "Ice Paper", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/Ice%20Paper%20-%20%E9%B8%A6%E9%9B%80%E6%97%A0%E5%A3%B0.mp3", pic: "http://p2.music.126.net/MLQl_7poLz2PTON6_JZZRQ==/109951163938219545.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 这两年过得好惭愧，不想成为一个业余的小残废原子性问题的由来、资源如何保护？原子性：一个或者多个操作在cpu执行的过程中不被中断的特性。原子性问题的源头就是线程切换（操作系统直接操作），这个又是依赖CPU中断的，简单理解禁止CPU发生中断就解决了原子性问题？1在单核cpu可以，多核并不行！ 例如：在32位CPU上的long类型的写操作12在32位系统中，禁止了cpu中断，那么两次写操作一定是要么同时执行，要么都没有被执行，具有原子性！多核CPU中long类型的写操作时，两个线程分别在CPU1，CPU2上。 此时禁止CPU中断只能保证CPU上线程执行，并不能保证同一时刻只有一个线程执行！也就是说并没有达到同一时刻只有一个线程执行的这个条件1锁模型的出现（不局限于java），我刚开始认为是这样的： 简易锁模型1典型的执行代码片段进行加锁和释放锁操作！ 完善锁模型但是详细的来讲，锁是什么？资源是什么？（保护的资源、锁）12锁：LR,受保护资源：R，加锁后，经临界区访问到R，完了释放锁。需了解LR和R的联系 。要明确用哪个锁保护哪个资源！（管程的博客） java-管程系列1-synchronized1234567891011121314151617181920class X &#123; // 修饰非静态方法（this） synchronized void foo() &#123; // 临界区 &#125; // 修饰静态方法（Class） synchronized static void bar() &#123; // 临界区 &#125; // 修饰代码块 Object obj = new Object()； void baz() &#123; synchronized(obj) &#123; // 临界区 &#125; &#125;&#125; 当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；当修饰非静态方法的时候，锁定的是当前实例对象 this。为什么看不到加锁，解锁的操作？因为jvm封装了Mintor来操作synchronized关键字，自动实现加锁和释放锁操作。 解决count+=112345678910class SafeCalc &#123; long value = 0L; long get() &#123; return value; &#125; synchronized void addOne() &#123; value += 1; &#125;&#125;被synchronized修饰后，无论是在单核还是多核都有且仅会有一个线程能执行addOne方法，原子性解决了。但是有么有解决可见性？ 管程中锁的规则：对一个锁的解锁happens-Before于后续对这个锁的加锁12简单说就是：前一个线程的解锁操作对后一个线程的加锁操作是可见的！但是此时，不小心在addOne 10000次的情况下动了get方法，那么这个时候get方法的可见性并不能保证。怎么解决？ 123456789class SafeCalc &#123; long value = 0L; synchronized long get() &#123; return value; &#125; synchronized void addOne() &#123; value += 1; &#125;&#125; 1转换成模型：此时get和addOne 是互斥的。还可以哈！ 锁和保护资源的关系1资源：锁 N:1挺好，现实生活中多个锁保护一个资源，但是并发领域会发生死锁等多个问题！把上面的代码中addOne方法改成static修饰！ 1234567891011121314class SafeCalc &#123; static long value = 0L; synchronized long get() &#123; return value; &#125; synchronized static void addOne() &#123; value += 1; &#125;&#125;get()是用的this，addOne()是用的SafeCalc.class，那么问题来了，你addOne修改了value的值，我get并不知道，可见性并不存在！NO所以说互斥这个东西贼鸡儿重要（爽）！ 不错！下面来看怎么用一把锁保护多个资源以及相关问题！保护没有关联关系的多个资源对账户余额和账户密码的保护1234567891011121314151617181920212223242526272829303132333435363738394041class Account &#123; // 锁：保护账户余额 private final Object balLock = new Object(); // 账户余额 private Integer balance; // 锁：保护账户密码 private final Object pwLock = new Object(); // 账户密码 private String password; // 取款 void withdraw(Integer amt) &#123; synchronized(balLock) &#123; if (this.balance &gt; amt)&#123; this.balance -= amt; &#125; &#125; &#125; // 查看余额 Integer getBalance() &#123; synchronized(balLock) &#123; return balance; &#125; &#125; // 更改密码 void updatePassword(String pw)&#123; synchronized(pwLock) &#123; this.password = pw; &#125; &#125; // 查看密码 String getPassword() &#123; synchronized(pwLock) &#123; return password; &#125; &#125;&#125;上述用balLock和pwLock来分别保护，当然可以使用同一个this来保护，但是性能太差都是变成串行操作了。贼慢！ 用多个锁对受保护资源进行精细化管理，能够提升性能美名其曰：细粒度锁。1保护有关联的多个资源：账户A-&gt;B(100)?代码化：Account(账户),成员变量：balance，transfer()怎么没有并发问题？ 12345678910111213141516171819202122232425class Account &#123; private int balance; // 转账 void transfer( Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125;正确？不正确加上synchronized正确？class Account &#123; private int balance; // 转账 synchronized void transfer( Account target, int amt)&#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125; 1234不正确synchronized只能锁住this.balance并不能锁住target.balance。假设A,B,C三个账户里面都有300块钱。A转账B 100，B转给C 100。期望是A还有200，B还是300，C 400块。假设线程1完成A-&gt;B,线程2完成B-&gt;C分别在两个不同的CPU上执行，但是他们并不互斥。怎么解决？ 使用一把锁覆盖所有的资源！12345678910111213141516171819class Account &#123; private Object lock； private int balance; private Account(); // 创建 Account 时传入同一个 lock 对象 public Account(Object lock) &#123; this.lock = lock; &#125; // 转账 void transfer(Account target, int amt)&#123; // 此处检查所有对象共享的锁 synchronized(lock) &#123; if (this.balance &gt; amt) &#123; this.balance -= amt; target.balance += amt; &#125; &#125; &#125;&#125; 12此时私有private Object lock，创建构造函数每一次都传入同一个对象lock。可以保证并发问题，但是在真实项目中多个工程中实现每次传入的lock都是同一个有点复杂（其实队列可以好好使用）还有就是使用Account.class作为锁。 1总结：解决原子问题就是解决操作的中间状态对外不可见！]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2-JMM浅谈]]></title>
    <url>%2F2019%2F03%2F10%2Fjavacurrent2%2F</url>
    <content type="text"><![CDATA[java内存模型 var ap = new APlayer({ element: document.getElementById("aplayer-iAHdehOp"), narrow: false, autoplay: true, showlrc: false, music: { title: "恋爱循环", author: "香菜", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/花澤香菜 - 恋愛サーキュレーション.mp3", pic: "http://p1.music.126.net/hWrYLdhzF4waj4WL1dFPmg==/642114790633458.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 1.导致可见性的原因是缓存：12有序性的原因是编译优化，合理的方案应该是“按需禁用缓存和编译优化”。java的内存模型是个很复杂的规范，从程序员的角度：java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法-&gt;volatile,synchronized,final三个关键字，以及六项Happens-Before规则。 2-volatile123456789101112131415161718192021222324252627282930313233volatile int x=1;//告诉编译器对这个x变量的读写不能使用CPU缓存，必须从内存中读或者写，但是实际运用中的困惑却很多！public class VolatileExample &#123; int x = 0; volatile boolean v = false; public void writer() &#123; x = 42; v = true; &#125; public void reader() &#123; if (v) &#123; System.out.println(&quot;x = &quot; + x); &#125; &#125;&#125;class Test &#123; public static void main(String[] args) throws InterruptedException &#123; VolatileExample volatileExample = new VolatileExample(); Thread A = new Thread(volatileExample::writer); Thread B = new Thread(volatileExample::reader); A.start(); B.start(); A.join(); B.join(); &#125;&#125;//x = 42解释：线程A执行writer方法，安装volatile语义会把变量“v=true”写到内存中，此时线程B执行reader方法，线程B会从内存中读取变量V，此时x结果为42。（java版本必须保证在1.5之后）JAVA1.5解决了CPU缓存导致可见性问题，Happens-Before规则。Happens-Before：前面一个操作的结果对后续的操作是可见的。约束了编译器的优化的行为，编译器优化必须遵循Happens-Before原则（6个原则）。 1.程序代码片段的顺序性规则 12345678910111213141516// 以下代码来源于【参考 1】1class VolatileExample &#123; 2 int x = 0; 3 volatile boolean v = false; 4 public void writer() &#123; 5 x = 42; //对x进行赋值 写 6 v = true;//对v进行赋值 写 7 &#125; 8 public void reader() &#123; 9 if (v == true) &#123;//此时需要读v 10 // 这里 x 会是多少呢？ 11 &#125; &#125;&#125;代码第5行x=42，对于第6行v=true来讲是可见的。（规则1）称之5 happens-before于6 2.Volatile变量规则1对一个volatile编写的写操作happens-before于后续对这个volatile变量的读操作。（在不关联3的时候，就是禁用缓存的意思。） 3.传递性A happens-before B，&amp; B happens-before C，那么A happens-before C。123x=42 happens-before v=true的写操作 规则1：程序的顺序性v=true 写操作 happens-before v=true的读操作 规则2 ： volatile修饰变量的可见性那么根据规则3 x=42 happens-before v=true的读操作！此时线程B能看到线程A中的x=42！ 4.管程中的锁–对一个锁的解锁 happens-before 于后续对这个锁的加锁。12管程：一种通用的同步原语-java实现synchronized（此过程的加锁释放锁（代码块执行完&#125;后）都是jvm帮我们实现的 底层：javap monitor机制）。 5.线程start规则1主线程A在启动子线程B后，子线程B能够看到主线程A再启动B前的操作。 6.线程join规则123456789101112131415指主线程A等待子线程B完成（A调用子线程B的join方法实现），当B完成操作后，主线程A能够看到B对共享变量的操作。Thread B = new Thread(()-&gt;&#123; // 此处对共享变量 var 修改 var = 66;&#125;);// 例如此处对共享变量修改，// 则这个修改结果对线程 B 可见// 主线程启动子线程B.start();B.join()// 子线程所有对共享变量的修改// 在主线程调用 B.join() 之后皆可见// 此例中，var==66假设B在线程A中执行，那么B中对变量var的修改 happens-before A,就是A都知道。 7.线程中断规则：12对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 8.对象终结规则：12345678910111213一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。final：修饰变量的时候，告诉编译器，这个变量生而不变（内地地址）。在正确的构造函数中没有“逸出”就不会出现问题！// 以下代码来源于【参考 1】final int x;// 错误的构造函数public FinalFieldExample() &#123; x = 3; y = 4; // 此处就是讲 this 逸出， global.obj = this;&#125; 思考：此时有可能访问到this还没有初始化完成！问题：一个共享变量a=3,在一个线程中设置了abc的值a=3，怎么让其他线程看到？跳出这个圈子–其实就是怎么解决缓存问题12341-volatile 修饰a2-加锁synchronized ，根据 happens-before 原则其他线程在A线程释放锁以后就会看到变量a3-A线程启动后使用A.join(),后续线程就可以看到4-直接使用static修饰]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1-学习java并发]]></title>
    <url>%2F2019%2F03%2F10%2Fjavacurrent1%2F</url>
    <content type="text"><![CDATA[导语：把握关键的6秒时差并发的学习不是简单的一两天能解决的，需要长期的学习，运用，总结。加油！大纲 ： var ap = new APlayer({ element: document.getElementById("aplayer-NIUEuKYA"), narrow: false, autoplay: true, showlrc: false, music: { title: "只想要你知道", author: "鬼卞", url: "http://20190313lhh.oss-cn-hangzhou.aliyuncs.com/%E5%8F%AA%E6%83%B3%E8%A6%81%E4%BD%A0%E7%9F%A5%E9%81%93.mp3", pic: "http://p2.music.126.net/6cxatxCqTNVhS4YcT5wGFQ==/109951163172559495.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 简单介绍：分工，同步，互斥分工12任务分解：多线程实现。Java SDK中Executor,Fork/Join ,Future。模式：生产-消费者，Worker-Thread(spark集群)，Thread-Per-Message。（合理的结合生活场景。） 同步12一个线程完成了一个任务，如何通知后续的任务线程开工。Future,CountDownLatch、CyclicBarrier、Phaser、Exchanger。核心是管程。 互斥123分工，同步解决的是性能问题。互斥讲的是线程安全问题--同一时刻只允许一个线程访问共享变量。JAVA：synchronized，lock；Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能，CAS更好！不共享变量或者只允许读：ThreadLocal，final，Copy-on-Write模式。 可见性，原子性，有序性就是并发的源头12并发(concurrency)：1:在同一时间间隔内，一个cpu,轮流执行多个任务(线程)。并行(parallellism)：1:讲究同时性--多个cpu同时执行多个任务(线程)。 并发程序之幕后123456789CPU,内存，I/O三者的速度差异-&gt;核心矛盾CPU&gt;&gt;内存&gt;&gt;I/O（天-&gt;年-&gt;1000年）程序中大部分代码会涉及访问操作系统内存+I/O，根据木桶理论(最短的那块板子，决定了一只木桶能装多少水！)，所以整个程序的性能取决于I/O读写操作。仅单方面提高CPU性能是无效的。目前合理利用CPU性能，平衡这三者的速度差异，计算机体系机构，操作系统，编译程序分别作了： 1.CPU增加了缓存-&gt;均衡了与内存的速度差异！ 2.操作系统增加了进程、线程分时复用CPU，为了均衡CPU和I/O的速度差异。 3.编译程序优化了指令执行次序，使得缓存能够得到更加合理的使用。 核心矛盾就是并发程序的诡异问题的根源！ 一、CPU缓存导致的可见性问题1单核CPU缓存和内存的数据一致性问题很好解决！下图CPU和内存的关系图！ 1234可见性：一个线程对共享变量的修改，另外一个线程能立刻看到！单核CPU上多个线程操作同一个CPU的缓存，一个线程对缓存的写，对另一个线程来说一定是可见的。上图：线程A和B同时操作同一个CPU的缓存，所以A更新了V的值，B之后再访问一定是拿到的最新的值。多核CPU,每个cpu都有自己的缓存！ 1234567891011121314151617181920212223242526272829此时A线程操作的是CPU-1上的缓存，B线程操作的是CPU-2上面的缓存，A线程对变量V的操作对于B线程来讲就是隐藏的。public class Test &#123; private long count = 0; private void add10K() &#123; int idx = 0; while(idx++ &lt; 10000) &#123; count += 1; &#125; &#125; public static long calc() &#123; final Test test = new Test(); // 创建两个线程，执行 add() 操作 Thread th1 = new Thread(()-&gt;&#123; test.add10K(); &#125;); Thread th2 = new Thread(()-&gt;&#123; test.add10K(); &#125;); // 启动两个线程 th1.start(); th2.start(); // 等待两个线程执行结束 th1.join(); th2.join(); return count; &#125;&#125;执行calc()方法会发现，打印结果小于20000，因为A，B两个线程启动的时候会被放到不同的CPU中执行，而此时只有一个内存，A从内存中把count读出来放到cpu缓存中+1,B也是这样，完了再把count放到内存中。当A,B线程同时发生的时候，会发现内存中的值为1，而不是我们期望的2。 二、线程切换-带来原子性问题1.例如单核CPU电脑上可以边听歌，边写bug，因为多进程存在的原因。1单核操作系统允许某个进程A执行一段时间-50ms，过了50ms会重新选择一个进程B来执行（线程切换），此时A线程不占有CPU，这个50ms叫做“时间片”。 2.Unix解决了？支持多进程分时复用–IO操作释放CPU，让CPU去做其他的任务！1234567891011121314前面提到CPU的速度&gt;&gt;I/O,当在一个时间片中，一个进程进行一个I/O操作的时候（读取一个文件），这个时候CPU发出一个指令就可以，但是I/O操作还会持续把文件读进内存，如果这个时候这个进程还在占有该CPU那么对于此时来讲，这个CPU是浪费的。可以在此时，该进程把自己标记为“休眠状态”并且让出CPU占有权，直到文件被读进内存后，操作系统唤起该进程，该进程可以继续获取到CPU的使用权。那么CPU发出一个指令直到文件被读进内存期间，CPU使用权被释放，那么CPU可以做别的事情了，CPU的使用率会提高；此外，如果这个时候有另外一个进程也在进行读取文件，那么这个读取文件的进程就会排队，磁盘驱动在完成上一个读操作后，发现有新的任务，则会立即启动下一个读进程，此时IO的使用率也会提高。早期的操作系统都是基于进程来调度CPU的，不同进程之间是不共享内存空间的，进程之间的任务切换就是切换内存映射地址。而一个进程所创建的所有的线程都是共享同一个内存空间的，SO,Thread之间进行任务切换就很低的成本了，现在的操作系统基本都是基于线程切换。JAVA并发程序都是基于多线程的，存在线程切换。java属于高级语言，代码中的一条语句往往需要多条CPU指令执行。count+=1;则需要3条CPU指令。1.把count从内存中加载到CPU寄存器。2.在寄存器中执行+1操作3.把此时count的结果写到内存中（也有可能写到CPU缓存）此时的任务切换可能发生在任意CPU指令执行后，而不是java中一句代码后。 123如图：线程切换会造成count+=1原子性问题。结果是1，不是期望的2.原子性：一个或者多个操作在CPU执行的过程中不被中断的特性。大头？如何在高级语言层面保证操作的原子性？ 三、编译优化带来的有序性问题。1234567891011121314151617181920212223242526272829编译器为了优化性能，会改变程序中语句的先后顺序。“a=6;b=7”会变成&quot;b=7;a=6&quot;这个不会影响程序的最终结果，但是下面：会有问题双重检查创建单例对象：public class Singleton &#123; static Singleton instance; static Singleton getInstance()&#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125;1：首先判断instance==null？是，则锁住Singleton.class并且再次检查instance==null？是，则创建Singleton的一个实例。A,B两个线程同时调用getInstance方法，他们同时发现instance==null，于是同时对Singleton.class加上锁,但此时JVM保证只会有一个线程加锁成功（假设是A），B则会等待。A会创建一个Singleton实例，之后释放锁，B会被唤醒，B会尝试加锁，此时会成功加锁，线程B检查instance==null会发现已经存在了Singleton实例则不会再创建。但是new操作的时候会出现问题！我们期望：1：分配一块内存M2：在内存M上初始化Singleton对象3：然后M的地址值赋给instance变量实际上：经过编译优化后！1：分配一块内存M2：把M的地址值赋值给instance对象3：最后在M上初始化SingletonA线程在完成“把M的地址值赋值给instance对象”这一指令之后就直接线程切换给了B线程，然后B线程判断instance！=null（此时都没有进入synchronized里面）但是，此时instance会有空指针异常！ 问题12long类型在32位操作系统上不安全？答案：long64位，所以在32位机器上对long类型的数据操作是由多条CPU指令组合来的，无法保持原子性。]]></content>
      <categories>
        <category>JAVA并发</category>
      </categories>
  </entry>
</search>
